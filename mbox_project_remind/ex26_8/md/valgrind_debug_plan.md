# Valgrind デバッグ練習サポート計画

## 目的
ユーザーが自力でvalgrindの出力を読んで問題を解明できるようサポートする

## 現状の理解
- ファイル: [ex26_8/ex26_8_6.c](ex26_8/ex26_8_6.c)
- 機能: mboxファイルから送信者のメールアドレスを抽出
- テストデータ: `/home/namae/pv/mbox_project_remind/mbox/google.mbox` (23MB)
- 推測: count_line関数（47-50行目）に問題がある
- 課題:
  - valgrindの出力が多い
  - .txtとして出力する方法が不明
  - 知識的な問題があるかもしれない

## ユーザーの学習方針
- valgrindの使い方と出力の読み方を学ぶ
- コードのバグを自分で見つける
- 間接的なヒントで進めたい

## サポート計画

### ステップ1: プログラムのコンパイル
- まずデバッグ情報付きでコンパイル
- `-g` オプションでデバッグシンボルを含める
- `-Wall` で警告も確認

### ステップ2: Valgrind実行環境のセットアップ
**基本コマンド構造:**
```bash
valgrind [valgrindオプション] ./プログラム [プログラム引数]
```

**推奨オプション:**
1. `--leak-check=full` - メモリリークの詳細情報
2. `--show-leak-kinds=all` - すべての種類のリークを表示
3. `--track-origins=yes` - 未初期化値の発生源を追跡
4. `--verbose` - 詳細な出力
5. `--log-file=valgrind_output.txt` - 出力をファイルに保存

**小さいテストケースの作成:**
- 23MBのファイルは大きすぎるため、最初の数行だけ抽出したテストファイルを使用
- `head -n 50 $MBOX/google.mbox > test_small.mbox`

### ステップ3: Valgrind出力の読み方ガイド

**主要なエラータイプ:**
1. **Invalid read/write** - 不正なメモリアクセス
   - 配列の範囲外アクセス
   - 解放済みメモリへのアクセス

2. **Conditional jump depends on uninitialised value(s)** - 未初期化変数の使用
   - 変数を初期化せずに条件式で使用

3. **Memory leak** - メモリリーク
   - "definitely lost" - 確実なリーク
   - "possibly lost" - 可能性のあるリーク
   - "still reachable" - プログラム終了時に到達可能だが解放されていない

**出力の構造:**
```
==PID== エラータイプ
==PID==    at 関数名: ファイル名:行番号
==PID==    by 呼び出し元: ファイル名:行番号
```

### ステップ4: 段階的デバッグアプローチ

1. **小さいテストケースで実行**
   - まず50行程度の小さいファイルで試す
   - エラーが再現するか確認

2. **エラーメッセージの分類**
   - どんな種類のエラーが出ているか
   - どの行番号が指摘されているか

3. **該当コードの分析**
   - エラーが指摘する行を確認
   - その周辺のロジックを理解

4. **問題の仮説立て**
   - なぜそのエラーが起きるか推測
   - C言語の仕様と照らし合わせる

### ステップ5: デバッグのヒント方針

**直接的に答えを言わないが、以下を提供:**
- 該当行のC言語の仕様説明
- 似たようなバグパターンの一般論
- 「この条件式はどんな時にtrueになるか？」のような誘導質問
- 必要に応じて、論理演算子や制御フローの復習

## 実行計画

1. デバッグビルドの作成方法を説明
2. 小さいテストケースの作成方法を提案
3. Valgrindの実行コマンド例を提示
4. 出力の読み方を説明
5. ユーザーが実行した結果を一緒に分析
6. 間接的なヒントで問題箇所の理解を促す
