ありがとうございます。では、まず全体構成の概要を示してから、Phase 1の詳細を展開します。残りのPhaseは、Phase 1を完了した後に順次提供する形にしましょう。

---

# ex28_binシリーズ：バイナリファイル処理の基礎

## 全体構成の概要

このシリーズは四つのPhaseで構成されており、テキストファイルとは本質的に異なるバイナリデータの世界を段階的に学びます。

**Phase 1: BMP画像ファイル処理**（これから詳細を展開）
BMPは最も単純な画像形式で、ヘッダー構造が明確に定義されています。テキストファイルが「文字の並び」なのに対し、バイナリファイルは「バイトの並び」であり、各バイトが特定の意味を持ちます。この違いを実感しながら、C言語の構造体とバイナリデータの対応関係を学びます。

**Phase 2: WAV音声ファイル処理**（Phase 1完了後に提供）
WAVファイルは「チャンク構造」という重要な概念を持っています。これは、ファイル内に複数のデータブロックが存在し、それぞれが独立した意味を持つという構造です。この概念はPDFや動画ファイルなど、多くの複雑なファイル形式の基礎となっています。

**Phase 3: PDF基本構造の理解**（Phase 2完了後に提供）
PDFは、人間が読めるテキスト部分とバイナリ部分が混在した複雑な形式です。ここでは、PDFの基本構造を理解し、PyMuPDFやPyPDF2がどのように動作しているかを学びます。これはex27シリーズへの準備にもなります。

**Phase 4: 動画ファイルのメタデータ抽出**（Phase 3完了後に提供）
MP4やMKVといった動画ファイルは、映像、音声、字幕など、複数のストリームを含む複雑な構造を持っています。ここでは、ffprobeなどのツールがどのようにメタデータを抽出しているかを理解し、自分でも基本的な情報を取得できるようになります。

各Phaseで、C言語による低レベル実装とPythonによる高レベル処理の両方を経験し、ex26_8で学んだ言語間連携の技術を実践的に活用します。

それでは、Phase 1の詳細を準備します。

---

# Phase 1: BMP画像ファイル処理

## 学習目標

このPhaseでは、バイナリファイルの基礎を学びます。テキストファイルとバイナリファイルの本質的な違いを理解し、C言語でバイナリデータを読み書きする方法を習得します。具体的には、BMP画像ファイルのヘッダー構造を解析し、画像の幅、高さ、色深度などのメタデータを抽出するツールを構築します。

## 理論的背景：テキストとバイナリの違い

あなたがこれまで扱ってきたmboxファイルは「テキストファイル」でした。テキストファイルでは、各バイトが文字を表現しています。例えば、バイト値0x41は文字'A'を意味し、0x0Aは改行を意味します。人間がエディタで開いたときに、意味のある文字列として読めるのがテキストファイルの特徴です。

一方、バイナリファイルでは、各バイトは数値そのものです。バイト値0x41は必ずしも文字'A'を意味せず、単に数値65を表現しているかもしれません。あるいは、隣接する4バイトを組み合わせて、一つの32ビット整数を表現しているかもしれません。バイナリファイルをテキストエディタで開くと、文字化けしたような表示になるのは、このためです。

C言語でファイルを開く際、`fopen()`の第二引数に`"r"`（読み込みモード）を指定するとテキストモードで開かれ、`"rb"`を指定するとバイナリモードで開かれます。テキストモードでは、改行コードの変換などが自動的に行われますが、バイナリモードでは、ファイルの内容がそのまま読み込まれます。

## BMP形式の基本構造

BMP（Bitmap）は、Windowsで使われる画像形式で、構造が非常にシンプルです。ファイルの先頭から順に、以下の情報が並んでいます。

ファイルヘッダー（14バイト）には、ファイルタイプ、ファイルサイズ、予約領域、画像データの開始位置が含まれます。情報ヘッダー（40バイト、標準的な場合）には、ヘッダーサイズ、画像の幅、画像の高さ、プレーン数、ビット深度、圧縮方式、画像データサイズ、解像度、使用色数、重要色数が含まれます。そして、カラーパレット（存在する場合）と実際の画像データが続きます。

このように、バイナリファイルは「決められた位置に、決められた形式で、決められた情報が入っている」という構造を持っています。これは、C言語の構造体と非常に相性が良い設計です。

## サンプルBMPファイルの準備

学習用のサンプルBMPファイルを用意します。Pythonで最小限のBMPファイルを生成するスクリプトを実行してください。

```python
# generate_sample_bmp.py
import struct

def create_simple_bmp(filename, width, height):
    """
    単純な赤色の画像を持つBMPファイルを生成する

    引数:
        filename: 出力ファイル名
        width: 画像の幅（ピクセル）
        height: 画像の高さ（ピクセル）
    """
    # BMPは4バイト境界にアラインする必要がある
    row_size = ((width * 3 + 3) // 4) * 4
    pixel_data_size = row_size * height
    file_size = 14 + 40 + pixel_data_size

    with open(filename, 'wb') as f:
        # ファイルヘッダー（14バイト）
        f.write(b'BM')  # ファイルタイプ（2バイト）
        f.write(struct.pack('<I', file_size))  # ファイルサイズ（4バイト）
        f.write(struct.pack('<H', 0))  # 予約領域1（2バイト）
        f.write(struct.pack('<H', 0))  # 予約領域2（2バイト）
        f.write(struct.pack('<I', 54))  # 画像データの開始位置（4バイト）

        # 情報ヘッダー（40バイト）
        f.write(struct.pack('<I', 40))  # ヘッダーサイズ
        f.write(struct.pack('<i', width))  # 画像の幅
        f.write(struct.pack('<i', height))  # 画像の高さ
        f.write(struct.pack('<H', 1))  # プレーン数
        f.write(struct.pack('<H', 24))  # ビット深度（24ビットカラー）
        f.write(struct.pack('<I', 0))  # 圧縮方式（0=無圧縮）
        f.write(struct.pack('<I', pixel_data_size))  # 画像データサイズ
        f.write(struct.pack('<i', 2835))  # 水平解像度（ピクセル/m）
        f.write(struct.pack('<i', 2835))  # 垂直解像度（ピクセル/m）
        f.write(struct.pack('<I', 0))  # 使用色数（0=全色）
        f.write(struct.pack('<I', 0))  # 重要色数（0=全色）

        # 画像データ（赤色の画像）
        for y in range(height):
            for x in range(width):
                f.write(bytes([0, 0, 255]))  # BGR形式（青、緑、赤）
            # 4バイト境界へのパディング
            padding = row_size - (width * 3)
            f.write(bytes([0] * padding))

if __name__ == '__main__':
    # 100x100ピクセルの赤い画像を生成
    create_simple_bmp('sample.bmp', 100, 100)
    print("sample.bmp を生成しました（100x100ピクセルの赤い画像）")
```

このスクリプトを実行すると、`sample.bmp`という100x100ピクセルの赤い画像ファイルが生成されます。

```bash
python3 generate_sample_bmp.py
```

生成されたファイルをWindowsの画像ビューアで開くと、赤い正方形が表示されるはずです。このファイルを使って、バイナリデータの読み取りを練習します。

それでは、最初の課題に進みましょう。

---

## ex28_bin_1: バイナリファイルの読み込みとHEX表示

**ファイル名**: `ex28_bin_1_hex_dump.c`

**目的**: バイナリファイルを読み込み、16進数形式で表示する基本的なツールを作る

**理論的背景**:

バイナリファイルを理解するための第一歩は、ファイルの内容を「生のバイト列」として観察することです。これを実現するのが、いわゆるHEXダンプツールです。Unixの`hexdump`や`od`コマンドと同じ機能を、C言語で実装します。

バイナリファイルを読み込むには、`fopen()`の第二引数に`"rb"`を指定します。`fread()`関数を使うと、指定したバイト数をバッファに読み込めます。テキストファイルの`fgets()`が「行単位」で読み込むのに対し、`fread()`は「バイト単位」で読み込みます。これがバイナリ処理の基本です。

読み込んだバイトを16進数で表示するには、`printf()`の書式指定子`%02X`を使います。これは「2桁の16進数、不足分は0で埋める」という意味です。例えば、バイト値255は`FF`と表示され、バイト値10は`0A`と表示されます。

**課題内容**:

`sample.bmp`ファイルを開き、先頭64バイトを16進数形式で表示するプログラムを書いてください。表示形式は、アドレス、16進数データ、ASCII表現の三列構成とします。

**要件**:

- バイナリモード（`"rb"`）でファイルを開くこと
- `fread()`で一度に16バイトずつ読み込むこと
- 各行の先頭にオフセットアドレスを表示（8桁の16進数）
- 16バイトを2桁の16進数で表示、各バイトはスペースで区切る
- 印字可能なASCII文字（0x20-0x7E）はそのまま表示、それ以外はドット（.）で表示
- 合計4行（64バイト）を表示

**実装のヒント**:

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

int main(int argc, char *argv[])
{
    FILE *fp;
    unsigned char buffer[16];  // 16バイトずつ読み込む
    size_t bytes_read;
    size_t offset = 0;
    int i;

    // 引数チェック
    if (argc < 2)
    {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        return (1);
    }

    // バイナリモードで開く（"rb"が重要）
    fp = fopen(argv[1], "rb");
    if (fp == NULL)
    {
        fprintf(stderr, "Error: Cannot open file '%s'\n", argv[1]);
        return (1);
    }

    // 4行分（64バイト）だけ表示
    for (int line = 0; line < 4; line++)
    {
        // 16バイト読み込む
        bytes_read = fread(buffer, 1, 16, fp);
        if (bytes_read == 0)
            break;

        // オフセットアドレスを表示（8桁の16進数）
        printf("%08zx  ", offset);

        // 16進数データを表示
        for (i = 0; i < 16; i++)
        {
            if (i < bytes_read)
                printf("%02x ", buffer[i]);
            else
                printf("   ");  // データがない部分は空白
        }

        printf(" |");

        // ASCII表現を表示
        for (i = 0; i < bytes_read; i++)
        {
            if (isprint(buffer[i]))
                printf("%c", buffer[i]);
            else
                printf(".");
        }

        printf("|\n");

        offset += bytes_read;
    }

    fclose(fp);
    return (0);
}
```

**コンパイルと実行**:

```bash
gcc -Wall -Wextra -Werror ex28_bin_1_hex_dump.c -o hexdump
./hexdump sample.bmp
```

**期待される出力**:

```
00000000  42 4d 36 30 00 00 00 00 00 00 36 00 00 00 28 00  |BM60......6...(.|
00000010  00 00 64 00 00 00 64 00 00 00 01 00 18 00 00 00  |..d...d.........|
00000020  00 00 00 30 00 00 13 0b 00 00 13 0b 00 00 00 00  |...0............|
00000030  00 00 00 00 00 00 00 00 ff 00 00 ff 00 00 ff 00  |................|
```

**学習ポイント**:

この出力から、BMPファイルの構造が見えてきます。最初の2バイト`42 4d`はASCIIで`BM`という文字列で、これがBMPファイルの識別子です。その後の4バイト`36 30 00 00`はリトルエンディアン形式でファイルサイズを表現しており、値は0x00003036（12342バイト）です。

`fread()`の戻り値が実際に読み込んだバイト数であることも重要です。ファイルの末尾に達した場合、16バイト未満しか読み込めないことがあります。そのため、`bytes_read`を使って、実際に読み込んだバイト数だけを処理します。

`isprint()`関数は、文字が印字可能かどうかを判定します。バイナリファイルには制御文字や拡張ASCII文字が含まれるため、そのまま表示すると端末が乱れることがあります。印字可能な文字だけを表示し、それ以外はドットで置き換えることで、安全に内容を確認できます。

ここまで理解できましたか。実際にコードを書いて実行してみて、疑問点があれば教えてください。次のexに進む前に、バイナリファイルの読み込みとHEX表示の仕組みを確実に理解しておきましょう。
