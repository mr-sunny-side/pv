# 08_ex29.py - POSTメソッドへの対応

## 概要

re07_ex29.pyではGETメソッドにおけるqueryパラメータへの対応とルーティングの学習を行いました。
08_ex29.pyでは、POSTメソッドの学習のためにその対応を追加していきます。

## POSTメソッドとGETメソッドの違い

### GETメソッド
- データはURLのクエリ文字列として送信される（例: `/search?q=test&page=1`）
- ヘッダーのみで完結する
- 1回の`recv(4096)`で全データを受信できることが多い

### POSTメソッド
- データはリクエストボディとして送信される
- ヘッダーとボディの2つの部分から構成される
- **Content-Lengthヘッダーを読み取り、そのサイズ分のボディを読み込む必要がある**

## POSTリクエストの構造

```
POST /login HTTP/1.1                              ← リクエストライン
Host: localhost:8080                              ← ヘッダー開始
Content-Type: application/x-www-form-urlencoded
Content-Length: 27                                ← ボディのサイズを示す
                                                  ← 空行（\r\n\r\n）= ヘッダー終了
username=test&password=1234                       ← ボディ（27バイト）
```

## POSTメソッド処理の実装手順

### 1. ヘッダーの終わりまで読み込む

```python
buffer = b''
while b'\r\n\r\n' not in buffer:
    chunk = client_socket.recv(4096)
    if not chunk:
        break
    buffer += chunk
```

**ポイント:**
- HTTPプロトコルでは、ヘッダーの終わりは**空行（`\r\n\r\n`）**で示される
- `b'\r\n\r\n'`が見つかるまで、4096バイトずつデータを受信し続ける
- この時点で`buffer`にはヘッダー全体と、場合によってはボディの一部も含まれている

### 2. ヘッダーとボディを分離

```python
header_end = buffer.find(b'\r\n\r\n')
headers_part = buffer[:header_end]
body_part = buffer[header_end + 4:]  # すでに読み込まれたボディの一部
```

**ポイント:**
- `find()`メソッドは、指定したパターンの**開始位置（インデックス）**を返す
- `header_end`は`\r\n\r\n`の開始位置
- `+ 4`は`\r\n\r\n`の4バイト分をスキップするため

#### find()メソッドの動作

```python
# 基本例
text = "Hello World"
pos = text.find("World")
print(pos)  # 6 ← "World"が6番目から始まる

# 見つからない場合
pos = text.find("Python")
print(pos)  # -1
```

#### 図解

```
buffer = b'POST /login HTTP/1.1\r\nHost: localhost\r\n\r\nusername=test'
         |←---------- headers_part ----------→|    |← body_part →|
         0                                    40   44
                                               ↑
                                        header_end (findの戻り値)
```

### 3. Content-Lengthヘッダーを取得

```python
headers = headers_part.decode('utf-8').split('\r\n')
content_length = 0
for header in headers[1:]:  # 最初の行はリクエストライン
    if header.lower().startswith('content-length:'):
        content_length = int(header.split(':', 1)[1].strip())
        break
```

**ポイント:**
- ヘッダー部分をデコードして、各行に分割
- `headers[1:]`: 最初の行（`POST /path HTTP/1.1`）をスキップ
- `lower()`で大文字小文字を区別しない比較
- `split(':', 1)`: コロンで最大2つに分割（値の中にコロンがあっても安全）

### 4. 残りのボディを読み込む

```python
while len(body_part) < content_length:
    chunk = client_socket.recv(content_length - len(body_part))
    if not chunk:
        break
    body_part += chunk
```

**ポイント:**
- ステップ2で既にボディの一部が読み込まれている可能性がある
- `Content-Length`で指定されたサイズになるまで、追加でデータを受信
- `recv(content_length - len(body_part))`: **残りのバイト数だけ**受信

**例:**
- Content-Length=1000で既に300バイト読み込み済み → あと700バイト受信

## なぜこの方法が必要か？

### GETメソッドの場合

```python
# これで十分
raw_data = client_socket.recv(4096)
```

### POSTメソッドの場合

- ボディのサイズが4096バイトを超える可能性がある
- 1回の`recv()`では全データを受信できない
- **Content-Lengthを見て、必要な分だけ受信し続ける必要がある**

## 実装に必要な追加項目

### Requestクラスの拡張

```python
class Request:
    def __init__(self):
        self.method = None
        self.path = None
        self.version = None
        self.query_str = None
        self.query = {}
        # 以下を追加
        self.headers = {}      # ヘッダー情報を格納
        self.body = b''        # リクエストボディを格納
```

### parse_http関数の拡張

- ヘッダーの解析機能を追加
- Content-Lengthの取得
- ボディの読み込み処理

### POSTハンドラーの追加

- フォームデータを受け取るハンドラー
- ボディのパース（例: `application/x-www-form-urlencoded`形式）

## 実装例（完全版）

```python
# 実際に試してみる
buffer = b'POST /test HTTP/1.1\r\nContent-Length: 10\r\n\r\nabcdefghij'

header_end = buffer.find(b'\r\n\r\n')
print(f"header_end = {header_end}")  # 39

headers_part = buffer[:header_end]
print(f"headers = {headers_part}")
# b'POST /test HTTP/1.1\r\nContent-Length: 10'

body_part = buffer[header_end + 4:]
print(f"body = {body_part}")
# b'abcdefghij'
```

## 次のステップ

1. Requestクラスに`body`と`headers`属性を追加
2. ヘッダーとボディを解析する関数を実装
3. POSTリクエストを受け取るハンドラーを作成
4. フォームデータのパース処理を実装

## 参考

- re07_ex29.py: GETメソッドとクエリパラメータの実装
- HTTPプロトコル仕様: ヘッダーとボディの区切りは`\r\n\r\n`
